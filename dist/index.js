var t,e,r,s={};function o(t,e,s=void 0){t==r.ERROR?console.error(r.ERROR,e,s):t==r.WARNING?console.warn(r.WARNING,e,s):console.log(r.LOG,e,s)}s.d=(t,e)=>{for(var r in e)s.o(e,r)&&!s.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),function(t){t.CREATED="CREATED",t.BOOTING="BOOTING",t.BOOTED="BOOTED"}(t||(t={})),function(t){t.IDLE="IDLE",t.RUNNING="RUNNING",t.STOPPED="STOPPED",t.ERROR="ERROR"}(e||(e={})),function(t){t.LOG="LOG :: ",t.ERROR="ERROR :: ",t.WARNING="WARNING :: "}(r||(r={}));const n=class{constructor(){this.programs=new Map,this.programState=new Map}isProgramExists(t){return this.programs.has(t)&&this.programState.has(t)}addProgram(t,s){this.programs.has(t)?o(r.WARNING,`Program ${t} already exists.`):(this.programs.set(t,new s),this.programState.set(t,e.IDLE))}startProgram(t,s=null){const n=this.programs.get(t);if(!n)return void o(r.WARNING,`Program ${t} not found.`);if(this.programState.get(t)!==e.RUNNING)if("function"==typeof n.onStart)try{n.onStart(s),this.programState.set(t,e.RUNNING)}catch(s){this.programState.set(t,e.ERROR),o(r.ERROR,`Error occured in program ${t} - `,s)}else o(r.ERROR,`onStart method is not defined in the program ${t}.`);else o(r.WARNING,`Program ${t} is already running.`)}endProgram(t){const s=this.programs.get(t);if(s)if(this.programState.get(t)===e.RUNNING)if("function"==typeof s.onDestroy)try{s.onDestroy(),this.programState.set(t,e.STOPPED)}catch(s){this.programState.set(t,e.ERROR),o(r.ERROR,`Error occured in program ${t} - `,s)}else o(r.ERROR,`onDestroy method is not defined in the program ${t}.`);else o(r.WARNING,`Program ${t} is not running.`);else o(r.WARNING,`Program ${t} not found.`)}getProgramsByState(t){const e={};for(const[r,s]of this.programState)s===t&&(e[r]=s);return e}getAllProgramStatus(){const t={};for(const[e,r]of this.programState)t[e]=r;return t}getProgramStatus(t){return this.programs.get(t)}};class a extends EventTarget{on(t,e,r){return this.addEventListener(t,e,r),()=>this.off(t,e)}once(t,e){this.addEventListener(t,e,{once:!0})}off(t,e){this.removeEventListener(t,e)}emit(t,e={}){return this.dispatchEvent(new CustomEvent(t,{detail:e}))}destroy(){}}const i=a;var h;function c(t){return fetch(t.url,{method:t.method||h.GET,headers:t.headers,body:t.body??null,signal:t.signal})}!function(t){t.GET="GET",t.POST="POST",t.PUT="PUT",t.PATCH="PATCH",t.DELETE="DELETE"}(h||(h={}));const d=class{async transform(t){const e=t.headers.get("content-type")||"";return e.includes("application/json")?await t.json():e.includes("text/")?await t.text():await t.blob()}};class g{constructor(t,e){if(new.target===g)throw new Error("Request is abstract");this.adapter=t??c,this.transformer=e??new d}get method(){return h.GET}get headers(){}get payload(){return null}get signal(){}async send(){try{this.onProcessing();const t=await this.adapter({url:this.url,method:this.method,headers:this.headers,body:this.payload,signal:this.signal});if(!t.ok)throw t;const e=await this.transformer.transform(t);return this.onSuccess(e),e}catch(t){throw this.onError(t),t}}onProcessing(){}onSuccess(t){}onError(t){}}const l=g;const u=class{constructor(){this.requests={}}addRequest(t,e){const r=new e(c);if(!(r instanceof l))throw new Error(`Invalid request "${t}". It must extend kernel Request class.`);this.requests[t]=r}startRequest(t){this.requests[t]||o(r.WARNING,"Request not found."),"function"!=typeof this.requests[t].send&&o(r.ERROR,"Send method not available for the request."),this.requests[t].send()}};const R=class{constructor(){this.programHandler=new n,this.eventHandler=new i,this.requestHandler=new u,this.state=t.CREATED,this.bootHandlers=[]}onBoot(e){this.state!=t.BOOTED?this.bootHandlers.push(e):e(this)}boot(){if(this.state===t.CREATED){this.state=t.BOOTING;for(const t of this.bootHandlers)t(this);this.bootHandlers.length=0,this.state=t.BOOTED}}registerPrograms(t){Object.keys(t).length&&Object.keys(t).forEach(e=>{this.programHandler.addProgram(e,t[e])})}start(t,e=null){this.programHandler.startProgram(t,e)}destroy(t){this.programHandler.endProgram(t)}emit(t,e={}){this.eventHandler.emit(t,e)}on(t,e,r){return this.eventHandler.on(t,e,r)}once(t,e){this.eventHandler.once(t,e)}registerRequests(t){Object.keys(t).length&&Object.keys(t).forEach(e=>{this.requestHandler.addRequest(e,t[e])})}send(t){this.requestHandler.startRequest(t)}status(){const t={};t.programs=this.programHandler.getAllProgramStatus(),console.log(t)}};export{R as Kernel,r as LoggerLevel,l as Request};